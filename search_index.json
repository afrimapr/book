[["index.html", "The afrimapr book Welcome", " The afrimapr book The afrimapr team 2021-03-17 Welcome This is the in-progress book introducing map making in R using African data. We aim to make a first version available in summer 2021. It is part of the afrimapr project running in 2020-21. The book is aimed principally at analysts who want to make maps from African data as a part of their routine work. We expect that readers will have had some limited experience of R and/or spatial data but this is not strictly required. We will take you step-by-step through code to obtain, manipulate and visualise spatial data. We focus on routine tasks and developing confidence and resilience in applying them, rather than moving to more advanced analyses. For those that are interested in spatial analyses we refer you to the excellent recent book Geocomputation with R. The afrimapr book, in comparison, will cover fewer processes but do so in more detail and assuming less prior knowledge of R and spatial data. We see the two books as being complementary. Those that wish to take their work further after this afrimapr book should find the geocompr book useful. Those that have been through the geocompr book and would like more detail on visualising varied data sources in R should find this afrimapr book useful. The book is compiled from this repository. We welcome contributions, and will make avenues for contribution clearer soon. In the meantime, do get in touch. "],["preface.html", "Preface", " Preface [defined in index.Rmd] [andy:links to chapters sometimes don’t work for unknown reasons] [https://bookdown.org/yihui/bookdown/cross-references.html] In-progress chapters Intro : aims of this book 1 Step through a simple example of process of mapmaking 2 R recap - help ensure readers know foundations 3 Spatial data types focusing on examples 4 Visualising spatial data part 1 : sf, mapview, tmap 5 Shiny interactive map applications 6 Sources of data, what is open data 7 Join non-spatial data onto spatial 8 Raster manipulation, e.g. summarising data by areas 9 OpenStreetMap data, what they are and how to use 10 Creating and editing spatial data 11 Visualising spatial data part 2, more advanced techniques 12 Case study 1 : health facility locations 13 Case study 2 14 The version of the book you are currently reading was last updated at: Sys.time() ## [1] &quot;2021-03-17 14:11:53 UTC&quot; Continuous integration (built on GitHub) "],["intro.html", "Chapter 1 Introduction 1.1 Spatial data outline", " Chapter 1 Introduction This first chapter is an entry level introduction to spatial data in R using examples from Africa. It is aimed at those with a little knowledge of R. 1.1 Spatial data outline We will start by looking at these spatial data for Africa, shown in the map below. Capital city locations (points) A highway network (lines) Country boundaries (polygons) Population density (gridded or raster data) Cities, highways and boundaries are examples of point, line and polygon data termed vector data. The gridded population density data are termed raster data. In R there is often more than one package that does the same thing. Which one is ‘best’ for you may depend on preference and can change over time. This is true for R spatial operations. In R the sf package deals with vector data (points, lines and polygons), and the raster package deals with raster data. There are other packages too but we don’t need those for now. "],["steps1.html", "Chapter 2 Step through a simple example of process of mapmaking", " Chapter 2 Step through a simple example of process of mapmaking Step through a simple example of process of map-making. Demonstrate a simple step by step process of making a map with relatively little explanation. To show the readers what we are aiming for and that this is achievable. Then in later chapters we will work to fill in the gaps in understanding https://speakerdeck.com/minecr/let-them-eat-cake-first "],["rrecap.html", "Chapter 3 R recap 3.1 Setting working directory 3.2 Creating, naming and saving a new R script 3.3 Executing the code 3.4 Install and load packages 3.5 Load data 3.6 Basic data types 3.7 Basic objects and data structures 3.8 Getting help with R Help 3.9 Wrap up 3.10 Feedback", " Chapter 3 R recap Previous section demonstrated what can be achieved with the learning materials provided in this book and gave an example of capabilities of packages that are used. This section presents basic steps that are required (or simply a good practice) before starting the project. It provides a brief recap of R fundamentals such as data types and structures, objects and commands. It aims at building a starting point for those who are new to R and provide a basic background knowledge that the reader can build on, while progressing through the further chapters of this book. It will be particularly useful for beginners, who have minimal knowledge of R. Therefore, more advanced readers can move forward to the next chapter where spatial data types are looked into. div.green { background-color:#e3ffd9; border-radius: 5px; padding: 20px;} Learning objectives create a working directory for his/her project create, name and save a new R script execute R code install and load an R package import data set into R space identify and characterise different data types classify and contrast various data structures accessing and using Help within R List of episodes Working directory New script Executing code Install packages Load data Basic data types Basic objects Getting help 3.1 Setting working directory At the beginning of each project it is crucial to determine the working directory for your project. A working directory is a folder where all your files associated with the project will be stored. For example, original data sets, saved data sets as well as plots, graphs or maps created and exported from R. Hence, working directory not only allows you to gather and access the files produced along the work but also load the existing data sets into the RStudio. You can set up the working directory with the openProject function as follows (recommended): rstudioapi::openProject(&quot;path to your directory&quot;) Alternatively, you can use the following command: setwd(&quot;path to your directory&quot;) While the former option will set up and open the working directory for your project, the latter simply determines the default folder for each specific R script. 3.2 Creating, naming and saving a new R script The R script is a plain text file that allows you to save the R code containing both, commands and comments. Saving the R script allows you to reuse your R code and creates a reproducible record of your work. Therefore, it is a good practice to create, name and save it at the very beginning of your project. You can crate a new R script by clicking the New File icon in the top right corner of the RStudio toolbar, which will open a list with different file options. Choose the R Script from the menu and the blank script will open in the main RStudio window. div.yellow { background-color:#fff5e6; border-radius: 5px; padding: 20px;} Shortcut: New R script can also be opened by Shift+Ctrl+N. You can now save your R script by clicking on the Save icon at the top of the Script Editor, this will prompt a Save File window where you can change the name of your script. Note that the file extension for R scripts is .R. At this point you can also choose a folder where to save your new file. By default, RStudio will try to save your new script in the current working directory. Once the name and file location are chosen, simply click the Save button. div.yellow { background-color:#fff5e6; border-radius: 5px; padding: 20px;} Shortcut: As you work along your R script document, you can quickly save changes by pressing Ctrl+S. 3.3 Executing the code Now, as you set up the working directory for your project and created your first R script file, we will look into ways of executing (also known as running) the code. You can execute selected chunk of code by clicking Run button at the top right corner of the Script Editor. div.yellow { background-color:#fff5e6; border-radius: 5px; padding: 20px;} Shortcut: You can also execute the selected code with Ctrl+Enter. If you do not select any code and press Run, RStudio will run the line of code where the cursor is located. The code which has been exectued will appear in the Console, usually located at the bottom part of the window. In RStudio it is also possible to add comments next to your commands simply using a hashtag (#) beforehand. This will stop R from executing this specific part: 3+6 # Using R as a calculator ## [1] 9 # 3+6 3.4 Install and load packages Before being able to use a specific package in R, it is necessary to firstly install and then load it. In this example we install package remotes using install.packages(): install.packages(&quot;remotes&quot;) Further, we have to load it into R using library() function: library(remotes) div.blue { background-color:#e6f0ff; border-radius: 5px; padding: 20px;} Please note the presence of the quotation mark \" \" in case of the first function and its lack in case of the second function. To download and install packages directly from remote repositories such as GitHub, we can use previously loaded remote package and load them as usual: remotes::install_github(&quot;afrimapr/afrilearndata&quot;) library(afrilearndata) In the example, above we use double-colon operator :: to call function install_github from name spaceremotes. Only functions which are included in the packages can be retrieved in this manner. 3.5 Load data There are different approaches that can be used to import your data sets, depending on where the data is located and in what file type it is stored. The easiest case is when the data set is already part of the R package, as it will be automatically read in when the package is installed and loaded into R. For example, install packages containing data set: remotes::install_github(&quot;afrimapr/afrilearndata&quot;) Load them: library(afrilearndata) To view what data sets are available in a given package: data(package=&quot;afrilearndata&quot;) We can view and explore the africapitals data set using: head(africapitals) ## capitalname countryname pop iso3c geometry ## 280 Abuja Nigeria 178462 NGA 7.17, 9.18 ## 308 Accra Ghana 2029143 GHA -0.20, 5.56 ## 382 Addis Abeba Ethiopia 2823167 ETH 38.74, 9.03 ## 996 Algiers Algeria 2029936 DZA 3.04, 36.77 ## 1584 Antananarivo Madagascar 1463754 MDG 47.51, -18.89 ## 2193 Asmara Eritrea 578860 ERI 38.94, 15.33 We can also create a dataframe from africapitals in the global environment: dataset &lt;- africapitals 3.6 Basic data types In this section we explore a basic set of possible object types that you can encounter in a dataframe. The division presented below is based on the types of values that data (object) stores. The most popular data types are: Numeric Character Logical (so-called Boolean) Factor In R the type of object is referred to as class of an object and this function can be used to learn what data types the object contains. x &lt;- 11 #we create a vector that stores value 11 class(x) ## [1] &quot;numeric&quot; It is useful because each class has different properties and can be used in a different way. For example, intuitively we can perform the mathematical operations on numeric objects such that: x &lt;- 11 y &lt;- 52 x*y # multiplication ## [1] 572 div.blue { background-color:#e6f0ff; border-radius: 5px; padding: 20px;} Hint: To assign a value to an object two operators can be used interchangeably: &lt;- or =. 3.6.1 Numeric and integer Numeric data stores real numbers. This means that the object x from above is in fact 11.000000, where the zeros are not printed, by default. It is also possible to store value as whole number in a class object called integer. An integer can be created from a numeric object in the following way: x &lt;- 13.5 z &lt;- as.integer(x) class(z) ## [1] &quot;integer&quot; Please note, even though the numeric value is a decimal number the integer by default rounds downwards, hence both 13.1 and 13.9 will result in integer equal 13. 3.6.2 Characters Character objects store text, usually referred to as a string. String can be a letter, word or even a sentence. x &lt;- &quot;adult&quot; y &lt;- &quot;A&quot; y &lt;- &quot;I have a bicycle.&quot; Interestingly, a character can also contain a number, however it will be stored as a text and will not have the same properties as a numeric or integer object. As a results, it will not be possible to perform calculation on character objects, even if they contain numbers. This is when class function becomes helpful. x &lt;- &quot;5&quot; y &lt;- 7 class(x) ## [1] &quot;character&quot; class(y) ## [1] &quot;numeric&quot; It is also possible to convert character variables into numeric: x &lt;- &quot;5&quot; z &lt;- as.numeric(x) class(z) ## [1] &quot;numeric&quot; 3.6.3 Logical Logical objects can take values TRUE or FALSE, where TRUE is an equivalent of 1 whereas FALSE is an equivalent of 0. In these sense, they can be thought of as numerical values. x &lt;- TRUE y &lt;- 3+TRUE print(y) ## [1] 4 Typically, logical objects are results of a condition. For example, if we want to test if object a is larger than 100. a &lt;- 76 #create object a a &gt; 100 # condition 1 ## [1] FALSE a &lt; 80 # condition 2 ## [1] TRUE 3.6.4 Factors Factors are categorical variables with associated levels. They can store both, numbers: a &lt;- rep(1:3, times=3) # create a vector of numbers from 1 to 3, repeated 3 times a &lt;- as.factor(a) a ## [1] 1 2 3 1 2 3 1 2 3 ## Levels: 1 2 3 and strings: b &lt;- c(&quot;A&quot;, &quot;B&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;C&quot;, &quot;C&quot;) b &lt;- as.factor(b) b ## [1] A B B C D C C ## Levels: A B C D The numbers and strings, in the example above, serve as labels of different levels. 3.7 Basic objects and data structures In this section we explain the basic data structures that we often work with in R. These include a vector, list, matrix and a data frame. 3.7.1 Vector Vector is a one dimensional structure which contains elements of the same type. Usually a combine function is used to create a vector such that: a &lt;- c(1:10) It is also possible to create a vector with text-based objects, for example with capitals from our afrilearndata: capitals &lt;- africapitals$capitalname We can print content of our vector to see what it contains: print(capitals) ## [1] &quot;Abuja&quot; &quot;Accra&quot; &quot;Addis Abeba&quot; &quot;Algiers&quot; &quot;Antananarivo&quot; ## [6] &quot;Asmara&quot; &quot;Bamako&quot; &quot;Bangui&quot; &quot;Banjul&quot; &quot;Bissau&quot; ## [11] &quot;Brazzaville&quot; &quot;Bujumbura&quot; &quot;Cairo&quot; &quot;Conakry&quot; &quot;Dakar&quot; ## [16] &quot;Dodoma&quot; &quot;Freetown&quot; &quot;Gaborone&quot; &quot;Harare&quot; &quot;Jibuti&quot; ## [21] &quot;Kampala&quot; &quot;Khartoum&quot; &quot;Kigali&quot; &quot;Kinshasa&quot; &quot;Libreville&quot; ## [26] &quot;Lilongwe&quot; &quot;Lome&quot; &quot;Luanda&quot; &quot;Lusaka&quot; &quot;Malabo&quot; ## [31] &quot;Maputo&quot; &quot;Maseru&quot; &quot;Mbabane&quot; &quot;Mogadishu&quot; &quot;Monrovia&quot; ## [36] &quot;N&#39;Djamena&quot; &quot;Nairobi&quot; &quot;Niamey&quot; &quot;Nouakchott&quot; &quot;Ouagadougou&quot; ## [41] &quot;Porto Novo&quot; &quot;Pretoria&quot; &quot;Rabat&quot; &quot;Tripoli&quot; &quot;Tunis&quot; ## [46] &quot;Windhoek&quot; &quot;Yamoussoukro&quot; &quot;Yaounde&quot; &quot;al-&#39;Ayun&quot; &quot;Juba&quot; Another important feature is to see what types of objects the vector stores. We can see that our text-based objects are characters using typeof function: typeof(capitals) ## [1] &quot;character&quot; 3.7.2 Matrix Matrix can be though of as an upgraded version of a vector, where vector is an one-dimensional array and two-dimensional array. We can create a matrix that has three columns and five rows with the following: matrix(1:15, ncol=3, nrow=5, byrow = TRUE) ## [,1] [,2] [,3] ## [1,] 1 2 3 ## [2,] 4 5 6 ## [3,] 7 8 9 ## [4,] 10 11 12 ## [5,] 13 14 15 By default, the elements in the matrix will be arranged by column, so byrow=TRUE segregates the elements in the matrix row-wise. We can also exploit the fact that matrix is an upgraded vector by binding them column- or row-wise, as long as they have the same length: vector1 &lt;- c(&quot;water&quot;, &quot;milk&quot;, &quot;juice&quot;) vector2 &lt;- (1:3) cbind(vector1, vector2) #for row-wise binding we would use rbind() ## vector1 vector2 ## [1,] &quot;water&quot; &quot;1&quot; ## [2,] &quot;milk&quot; &quot;2&quot; ## [3,] &quot;juice&quot; &quot;3&quot; 3.7.3 Data frame Data frame is a two dimensional array, similar to a matrix. However, it can contain different data types, unlike matrix. Beyond, columns as well as rows within the data frame are named. In a data frame a column is a variable and row is an observation. You can create a simple data frame with two columns and three rows, using vectors above, with data.frame function: data.frame(vector1, vector2) ## vector1 vector2 ## 1 water 1 ## 2 milk 2 ## 3 juice 3 If you compare the output of the example above where we used the cbind function to create a matrix, to the result of the data.frame function, we can clearly see the difference between a matrix and a data frame. Where matrix is homogeneous and data frame is heterogeneous in terms of data type. All the values in the matrix are characters while the first column in data frame contains factors and the second one integers. To address a specific column in a data frame we can use $ such that: df_1 = data.frame(vector1, vector2) #create data frame called df_1 df_1$vector1 #view column called vector1 ## [1] &quot;water&quot; &quot;milk&quot; &quot;juice&quot; At the moment columns in the df_1 adapted names of the vectors: colnames(df_1) ## [1] &quot;vector1&quot; &quot;vector2&quot; We can change the column headers by their names or their index such that: names(df_1)[names(df_1) == &quot;vector1&quot;] &lt;- &quot;drinks&quot; names(df_1)[2] &lt;- &quot;amount&quot; colnames(df_1) ## [1] &quot;drinks&quot; &quot;amount&quot; 3.8 Getting help with R Help R is a powerful software with many different packages and functions which are continuously developed and added. Therefore, it is difficult, if not impossible, to be familiar with all the functions that are currently available. Hence, in order to learn more about them, R provides extensive documentation which can be accessed with help() function, ? operator or by clicking in Help panel in the bottom-right corner. For example: help(matrix) #to find out what matrix is help(package=&quot;remotes&quot;) #to get help with remotes package Alternatively, it is possible to use ? in front of the searched item and the R documentation will appear in right-bottom pane. For example, to read more on how to use help function itself we can use: ?help Importantly, in order to get help regarding objects with unusual names such as the logical operators, it is necessary to use quotation marks: ?&quot;&amp;&quot; help(&quot;!&quot;) R documentation for functions frequently offers a working example which can be accessed with: example(vector) #to see an example of a vector ## ## vector&gt; df &lt;- data.frame(x = 1:3, y = 5:7) ## ## vector&gt; ## Error: ## vector&gt; try(as.vector(data.frame(x = 1:3, y = 5:7), mode = &quot;numeric&quot;)) ## Error in as.vector(data.frame(x = 1:3, y = 5:7), mode = &quot;numeric&quot;) : ## &#39;list&#39; object cannot be coerced to type &#39;double&#39; ## ## vector&gt; x &lt;- c(a = 1, b = 2) ## ## vector&gt; is.vector(x) ## [1] TRUE ## ## vector&gt; as.vector(x) ## [1] 1 2 ## ## vector&gt; all.equal(x, as.vector(x)) ## FALSE ## [1] &quot;names for target but not for current&quot; ## ## vector&gt; ###-- All the following are TRUE: ## vector&gt; is.list(df) ## [1] TRUE ## ## vector&gt; ! is.vector(df) ## [1] TRUE ## ## vector&gt; ! is.vector(df, mode = &quot;list&quot;) ## [1] TRUE ## ## vector&gt; is.vector(list(), mode = &quot;list&quot;) ## [1] TRUE Finally, the Internet also provides several reliable sources such as official R website or documentation pages where you can find help. 3.9 Wrap up In this chapter we learned several R commands which prepared the reader for starting with his/her own project. Moreover, we familiarised with a number of data types and R objects. Moreover, we looked at how to obtain help and access R documentation. The material covered in this section aimed at building a base for the reader to allow him/her successfully progress through the book. 3.10 Feedback "],["data-types.html", "Chapter 4 Chapter 4 Spatial data types with focus on real examples 4.1 Overall goal of the chapter 4.2 4.1 Points 4.3 4.2 Lines 4.4 4.3 Polygons 4.5 4.4 Rasters 4.6 Summary/key points 4.7 4.5 Wrap up with final exercises 4.8 4.6 Further resources 4.9 4.7 Feedback", " Chapter 4 Chapter 4 Spatial data types with focus on real examples 4.1 Overall goal of the chapter Previous chapter provided a short recap of the R basics that are necessary to succesfully work through the geospatial training that has been drawn up in this book. This section will start with the very basics of geospatial mapping: the 4 different types of spatial data types that you will encounter. The goal of any spatial map is to model reality, whether this is on the scale of a house, a neighbourhood, a country or a continent. Depending on the topics you’re interested in, this could be focussed on disease cases, landcover dynamics, location of schools and so on. The opportunities are endless. All the R software needs is information to visualise spatial data in a digital format. This is achieved by loading different spatial data types, which together form a model of reality. This section presents the four main data types: points, lines, polygons and rasters. –&gt; interactive image with a different layer for points, lines, polygons and rasters (need help doing this, without the need to load data first..) #mapview(list(africapitals, afrihighway), # zcol = list(‘pop’,‘Name’), # legend = list(TRUE, FALSE), # color = list(NULL, ‘red’), # label = list(paste(africapitals\\(countryname,&#39;:&#39;,africapitals\\)capitalname), # afrihighway$Name) ) All spatial data types require a spatial reference frame or coordinate system identification to place data in the correct location in space. We will discuss this in more detail in chapter xxx. For now, just be aware that apart from your data file, additional data is necessary to place your points, lines, polygons and rasters in the correct location. div.blue { background-color:#e6f0ff; border-radius: 5px; padding: 20px;} Please note that spatial data types can be stored in many different formats, from Shapefile (.shp + .dbf + .prj + …), to GeoPackage (.gpkg), to CSV files (.csv). This can be overwhelming sometimes. Don’t hesitate to contact the owner of the data or use google to find out more! This chapter is written for beginners, who have basic knowledge of R and no experience with spatial data. If you are familiar with the basic spatial data types, you can move on to the next chapter where visualisation of data types are explained in more detail. div.green { background-color:#e3ffd9; border-radius: 5px; padding: 20px;} 4.1 Learning objectives Describe the difference between points, lines, polygons and raster data types Identify data files from the four different spatial data types Open data files from the four different spatial data types in R Visualise data files from the four different spatial data types in R 4.1.1 List of episodes Points (cities) Lines (roads) Polygons (country boundaries) Rasters (population density) 4.2 4.1 Points div.green { background-color:palegreen; border-radius: 5px; padding: 20px;} 4.2 Learning objectives Identify point data files Open point data files Visualise point data files Let’s take an imaginary walk outside. What do you see? Houses, cars, trees… All these objects have unique coordinates that can be used to identify their exact location. On a map, the objects can be drawn as points with their latitude and longitude coordinate indicating their exact location in relation to other objects and places. Depending on the scale of your map, points can represent anything from a house, health clinic, city or district. You, as the map creator, can decide the scale of your own map. 4.2.1 Example Lets try and visualise the capital cities of Africa. Just a quick reminder of the necessary packages library(afrilearndata) #load afrilearndata package #In case the data isn&#39;t loaded into your R environment automatically, they can be individually loaded using the codes below. data(africountries) #borders of the African countries data(africapitals) #location of the African capitals data(afrihighway) #the main highways in Africa data(afripop2000) #The population density accross Africa (Worldpop) We will start by downloading the necessary packages: sf package. This package is necessary to read in the spatial data files. tmap package. This package is necessary to create the maps. #install.packages(&quot;sf&quot;) #install sf package #install.packages(&quot;tmap&quot;) #install tmap package library(sf) #load sf package library(tmap) #load tmap package div.blue { background-color:#e6f0ff; border-radius: 5px; padding: 20px;} Please note that more information can be found about the different packages using the Help tools explained in chapter 3.8 Now, let’s look at the data file that contains information about the African capitals. A quick summary of the spatial aspects (geometry) of the datafile can be checked using the following code: print(st_geometry(africapitals)) #printing information on the geometry ## Geometry set for 50 features ## Geometry type: POINT ## Dimension: XY ## Bounding box: xmin: -17.48 ymin: -29.31 xmax: 47.51 ymax: 36.84 ## Geodetic CRS: WGS 84 ## First 5 geometries: We can see from the results that the African capital data file contains 50 points (capitals) with geometry type POINT. Let’s print the first 6 rows of data, so we can see how the coordinates of each African captial is stored in the database. head(africapitals) #First 6 rows of data are printed ## Simple feature collection with 6 features and 4 fields ## Geometry type: POINT ## Dimension: XY ## Bounding box: xmin: -0.2 ymin: -18.89 xmax: 47.51 ymax: 36.77 ## Geodetic CRS: WGS 84 ## capitalname countryname pop iso3c geometry ## 280 Abuja Nigeria 178462 NGA POINT (7.17 9.18) ## 308 Accra Ghana 2029143 GHA POINT (-0.2 5.56) ## 382 Addis Abeba Ethiopia 2823167 ETH POINT (38.74 9.03) ## 996 Algiers Algeria 2029936 DZA POINT (3.04 36.77) ## 1584 Antananarivo Madagascar 1463754 MDG POINT (47.51 -18.89) ## 2193 Asmara Eritrea 578860 ERI POINT (38.94 15.33) The capitals all have one latitude and one longitude value. The geometry of the point data is stored as POINT (Latitude, Longitude). On the location where the latitude and longitude overlap, a point will be drawn when POINT data is visualised. div.blue { background-color:#e6f0ff; border-radius: 5px; padding: 20px;} Please note that this database also includes the population of the capital as a seperate data column. Let’s now visualise the African capitals by plotting their geometry using the tmap package. # tm_shape(africapitals) + #specify the data file # tm_dots() # displaying the point geometry The tmap package works similar to the ggplot package. You need to first specify the data file you want to visualise using tm_shape(), after which the exact format of the spatial data can be specified. As we are working with point data in this example, the tm_dots() function is used. As with ggplot, there is a lot of flexibility in the colouring, shapes and sizes of the dots. For example, the dots can be turned red and labelled with the name of the city. # tm_shape(africapitals) + # tm_dots(&quot;red&quot;)+ # displaying the point geometry as red dots # tm_text(&quot;capitalname&quot;, size=0.7 ) #adding the name As you can see in the example above, the labelling makes the image messy. In these instances it is important to think about the message you are trying to convey. If the labelling is essential, you can look up the help section of the ‘tm_text’ using the help tool and play around with the different options to clean up the image. 4.2.2 Exercise 1 In this first exercise, we will use the same African capital data as our example. Below, We have visualised all capitals with &gt; 1.400.000 people using green squares of size 1. However, the code isn’t working. Can you find the four mistakes? Hint: if you get stuck, look at ‘?tm_dots’ #africapitals_ex1=africapitals %&gt;% # filter(as.factor(`pop`) &gt; 1.400.000) #tm_shape(africapitals_ex1) + # tm_dots(&quot;green&quot;, size=0.5) Answer: In the initial filter, as.factor needs to be changed to as.numeric Dots in 1.400.000 need to be removed The shape of the dots need to be specified as squares using shape=22 The size of the points needs to be 1. #africapitals_ex1=africapitals %&gt;% # filter(as.numeric(`pop`) &gt; 1400000) #tm_shape(africapitals_ex1) + # tm_dots(&quot;green&quot;, shape = 22, size=1) 4.2.3 Exercise 2 We will now use a different data type. We will download the locations of the big universities in Africa using open street map. 4.3 4.2 Lines div.green { background-color:#e3ffd9; border-radius: 5px; padding: 20px;} 4.3 Learning objectives Identify line data files Open line data files Visualise line data files In previous episode we looked at point data on a map. We are often interested in how these different points on a map are connect to eachother. Roads, rivers and flight pathes are just a few of the many ways that lines are used. Lines are one dimensional data which are drawn using points (and thus point data) connected to eachother in a set order. Depending on the detail of the lines, more or less points can be used. 4.3.1 Example For this example, we will look at the trans african highway network. Let’s start by looking at a quick summary of the spatial aspects (geometry). print(st_geometry(afrihighway)) #printing information on the geometry ## Geometry set for 100 features ## Geometry type: LINESTRING ## Dimension: XYZ ## Bounding box: xmin: -17.38929 ymin: -33.95247 xmax: 43.13781 ymax: 37.08586 ## z_range: zmin: 0 zmax: 0 ## Geodetic CRS: WGS 84 ## First 5 geometries: The results show that the African highway network contains 100 lines with geometry type LINESTRING. Let’s now print the first 6 rows of data to see how line data is stored. head(afrihighway) #First 6 rows of data are printed ## Simple feature collection with 6 features and 1 field ## Geometry type: LINESTRING ## Dimension: XYZ ## Bounding box: xmin: -17.36938 ymin: 14.76957 xmax: -6.800537 ymax: 33.98436 ## z_range: zmin: 0 zmax: 0 ## Geodetic CRS: WGS 84 ## # A tibble: 6 x 2 ## Name geometry ## &lt;chr&gt; &lt;LINESTRING [°]&gt; ## 1 Western Sahara (Morocco… Z (-16.94778 21.34438 0, -16.85303 21.96343 0, -16.5… ## 2 Mauritania Border- Daka… Z (-17.36938 14.76957 0, -16.9519 14.77488 0, -16.73… ## 3 Nouakchott- Senegal Bor… Z (-15.81069 16.52036 0, -16.11694 16.72039 0, -16.1… ## 4 Western Sahara Border- … Z (-15.99128 18.08646 0, -16.01807 18.49003 0, -16.1… ## 5 Marrakesh- Western Saha… Z (-12.95837 27.67623 0, -12.7002 28.0041 0, -12.128… ## 6 Rabat- Marrakesh Link Z (-8.12439 31.79238 0, -8.02002 31.8589 0, -7.91564… Line data contain a string of data points with latitude and longitude: LINESTRING(Latitude1, Longitude1, Latitude2, Longitude2, Latitude3, Longitude3,.. ). During mapping, these points are connected to form a line. Lets visualise these linestrings in red by plotting their geometry using the tmap package. # tm_shape(afrihighway) + # tm_lines(&quot;red&quot;) #similar to tm_dots colour of the lines can be specified. div.blue { background-color:#e6f0ff; border-radius: 5px; padding: 20px;} Please check out the help section to familiarise yourself with the many layout options available. Now we can add the capitals from previous episode in blue # tm_shape(africapitals) + # tm_dots(&quot;blue&quot;, size=0.5)+ # tm_shape(afrihighway) + # tm_lines(&quot;red&quot;) # displaying the point geometry as red dots When both points and lines are mapped, datasets need to be identified seperately in tm_shape() before the use of tm_dots() and tm_lines(). div.blue { background-color:#e6f0ff; border-radius: 5px; padding: 20px;} Please note that the order of tm_dots() and tm_lines() matters. If you want the points overlaying the lines, it should be placed after the lines coding and visa versa. 4.3.2 Exercise 1 In the below exercise we have tried to visualise all the capitals and only the roads starting with the letter ‘b’. However, we have messed up the order of the code. Can you rearrange the code? #need to check the code before rearranging it afrihighway_ex1=afrihighway[grep(&quot;^B&quot;, afrihighway$Name),] # tm_shape(africapitals) + #important that capitals are visualised first # tm_dots(&quot;blue&quot;, size=0.5)+ # tm_shape(afrihighway_ex1)+ # tm_lines(&quot;blue&quot;) 4.3.3 Exercise 2 (rivers in Africa, flight paths?) make this slightly more complicated by selecting rivers than are at least 100 km long? 4.4 4.3 Polygons div.green { background-color:#e3ffd9; border-radius: 5px; padding: 20px;} 4.4 Learning objectives Identify polygon data files Open polygon data files Visualise polygon data files If a line has the same first and last coordinate, this creates a closed figure: a polygon. Similar to lines, depending on the detail of the map, more or less points can be used to create a polygon. Polygons are two dimension data. Examples include country boundaries and continent outlines. Often times one polygon is not sufficient to visualise complicated shapes. Several polygons are necessary: these shapes are called mulipolygons. The different polygons in one data row indicate either areas to include or exclude from the final image. For example the continent outline of Africa is a multipolygon. plot(st_geometry(africontinent), col = &quot;lightblue&quot;) One polygon is used to visualise mainland of Africa. An additional polygon is used for Madagascar. Together they represent the whole African continent. –&gt; This might be a simple polygon and not a multipolygon… An example of a multipolygon where areas are excluded is the country border of South Africa. Lesotho is entirely surrounded by South Africa. If we want to visualise South Africa, we need to make sure that the Lesotho area is excluded. Visualisation of South Africa therefore requires two polygons, one to outline the outer borders and one to highlight the area to exclude (Lesotho country borders). #africountries_ex=africountries %&gt;% # filter(`name` == &quot;South Africa&quot;) #plot(st_geometry(africountries_ex), col = &quot;lightblue&quot;) As you can see in the image above, when the border lines of South Africa are visualised, a white area is visible inside the country (representing Lesotho), which is not part of South Africa. 4.4.1 Example print(st_geometry(africountries)) #printing information on the geometry ## Geometry set for 51 features ## Geometry type: MULTIPOLYGON ## Dimension: XY ## Bounding box: xmin: -17.62504 ymin: -34.81917 xmax: 51.13387 ymax: 37.34999 ## Geodetic CRS: WGS 84 ## First 5 geometries: The country border file contains 51 country outlines with geometry type MULTIPOLYGON. If we print the first 6 rows of data, we can see how each country border is stored in the database head(africountries) #First 6 rows of data are printed ## Simple feature collection with 6 features and 11 fields ## Geometry type: MULTIPOLYGON ## Dimension: XY ## Bounding box: xmin: -17.06342 ymin: -13.25723 xmax: 51.13387 ymax: 27.65643 ## Geodetic CRS: WGS 84 ## name name_long pop_est gdp_md_est ## 1 Tanzania Tanzania 53950935 150600.0 ## 2 W. Sahara Western Sahara 603253 906.5 ## 11 Dem. Rep. Congo Democratic Republic of the Congo 83301151 66010.0 ## 12 Somalia Somalia 7531386 4719.0 ## 13 Kenya Kenya 47615739 152700.0 ## 14 Sudan Sudan 37345935 176300.0 ## lastcensus income_grp iso_a3 geometry ## 1 2002 5. Low income TZA MULTIPOLYGON (((33.90371 -0... ## 2 NA 5. Low income ESH MULTIPOLYGON (((-8.66559 27... ## 11 1984 5. Low income COD MULTIPOLYGON (((29.34 -4.49... ## 12 1987 5. Low income SOM MULTIPOLYGON (((41.58513 -1... ## 13 2009 5. Low income KEN MULTIPOLYGON (((39.20222 -4... ## 14 2008 4. Lower middle income SDN MULTIPOLYGON (((24.56737 8.... ## name_fr name_pt name_af ## 1 Tanzanie Tanzânia Tanzanië ## 2 Sahara occidental Saara Ocidental Wes-Sahara ## 11 Congo-Kinshasa Congo - Kinshasa Demokratiese Republiek van die Kongo ## 12 Somalie Somália Somalië ## 13 Kenya Quênia Kenia ## 14 Soudan Sudão Soedan ## name_sw ## 1 Tanzania ## 2 Sahara Magharibi ## 11 Jamhuri ya Kidemokrasia ya Kongo ## 12 Somalia ## 13 Kenya ## 14 Sudan Geometry data contains a list within multiple polygons that are represented as data points with latitude and longitude. These points are connected to form multiple polygons which are either used to include or exclude areas from the final image. The geometry of the multipolygon data is stored as MULTIPOLYGON (((Latitude1, Longitude1, Latitude2, Longitude2, Latitude3, Longitude3,.. ),(Latitude1, Longitude1, ..)),(Latitude1, Longitude1, …))). This needs further clarification. Lets visualise these multipolygons in black # tm_shape(africountries) + # tm_borders() #if only borders need to be visualised # # tm_shape(africountries) + # tm_polygons() #if you want the image to specify the multipologon area Now we can add the capitals and highways from previous episodes # tm_shape(africountries) + # tm_borders()+ # tm_shape(africapitals) + # tm_dots(&quot;blue&quot;, size=0.5)+ # tm_shape(afrihighway) + # tm_lines(&quot;red&quot;) # displaying the point geometry as red dots 4.4.2 Exercise 1 Multiple choice to identify if datafiles contain point, line or multipolygon geometry -need to identify two different datafiles to use. –&gt; list of data : the students need to identify what kind of geometry type the data file contains –&gt; Visual example: the students need to identify what kind of geometry type the data file contains that is visualised in the example. a Point data b Line data c Multipolygon data d All of the above If wrong: go back (explain why wrong) 4.4.3 Exercise 2 (different data: game reserves) Visualise the Malawi country border in black and district borders in green. Points, lines and polygons are grouped together as vector data. Several points together can form a line and several lines together form a polygon. They are all dependent on coordinates and their datafiles look very similar. Rasters are a group of their own. They are made up of a grid of pixels, with each grid containing values. 4.5 4.4 Rasters div.green { background-color:#e3ffd9; border-radius: 5px; padding: 20px;} 4.5 Learning objectives Explain the difference between vector and raster data Identify raster data files Open raster data files Visualise raster data files Episode 1 to 3 are focussed on vector data. Vector data uses points, lines, polygons to model the real world. I extracted the text below. Needs to be re-written. Raster data is a matrix of grid cells. Each cell represents a geographical location and contains a value that represents a characteristict of that region [ref]. Represents large areas with continuously changing values. –&gt; image of a simple raster: with data Raster data is used when displaying information that is continuous across an area and cannot easily be divided into vector features(vectors aren’t very good at representing features that are not homogeneous). examples: population density, landcover variation, elevation. Rasters are often backdrop for vector data. Raster data is extracted from eg. satellite imagery, drone imagery, surveys, Depending on the number of grid cells, this can result in a smooth image, or visualisation of individual grid cells. Raster datasets can become potentially very large because they record values for each cell in an image. As resolution increases, the size of the cell decreases. But this comes at a cost for speed of processing and data storage. To read in raster data, we need to install and load the ‘raster’ package. #install.packages(&quot;raster&quot;) #install sf package library(raster) # load raster package 4.5.1 Example To show raster data, in this example we use population data from 2000 and 2020. #print(afripop2000) #printing information on the raster data file The population raster data from 2000 contains 434 rows, 413 columns and a total of 179242 grid cells with geometry type RasterLayer . If we print the first 6 rows of data, we can see how each country border is stored in the database #head(afripop2000) #First 6 rows of data are printed Why do you think the first 6 data points are empty? Better to see a few more grid cells in the raster layer. #getValues(afripop2000) The raster layer consists of a matrix with values. The grid cells can be empty if no data is available. Lets visualise the population data with the country borders (example from afrilearnr. #tm_shape(afripop2020) + # tm_raster(palette = rev(viridisLite::magma(5)), breaks=c(0,2,20,200,2000,25000)) + #tm_shape(africountries) + # tm_borders() div.blue { background-color:#e6f0ff; border-radius: 5px; padding: 20px;} Please note that population density data are highly skewed. To ensure both high and low density areas are clearly visible, we have to specify the data breaks manually. Now we can add the capitals and highways from previous episodes #tm_shape(afripop2020) + # tm_raster(palette = rev(viridisLite::magma(5)), breaks=c(0,2,20,200,2000,25000)) + #tm_shape(africountries) + # tm_borders(&quot;white&quot;, lwd = .5) + #tm_shape(afrihighway) + # tm_lines(col = &quot;red&quot;) + #tm_shape(africapitals) + # tm_symbols(col = &quot;blue&quot;, alpha=0.4, scale = .6 )+ #tm_legend(show = FALSE) 4.5.2 Exercise 1 4.5.3 Exercise 2 (different data: elevation data?) 4.6 Summary/key points Points are .. Lines are .. Polygons are .. Rasters are .. 4.7 4.5 Wrap up with final exercises In this chapter we learned xxxx Try to solve the exercises below tp ### 1 Visualise 4.7.1 2 User story 4.8 4.6 Further resources If you are interested in learning more about the different spatial data types, please visit: Geospatial workshop Geospatial data organization Introduction to geospatial data Raster and vector data 4.9 4.7 Feedback Request on what was useful to the reader (learner) and what can be improved: Is this necessary after each chapter? Feels slightly repetitive. "],["visualising1.html", "Chapter 5 Visualising spatial data part 1: tmap and mapview 5.1 Overall goal of the chapter 5.2 Quick interactive maps with mapview 5.3 Static maps with tmap 5.4 Interactive maps with tmap 5.5 Further resources 5.6 Exercise solutions", " Chapter 5 Visualising spatial data part 1: tmap and mapview 5.1 Overall goal of the chapter In the previous section we explored different types of spatial data and looked at how these can be used to create a map. In this section we will use tmap and mapview packages to crate both static and interactive maps. In particular, we will focus on the goals presented below. div.green { background-color:#e3ffd9; border-radius: 5px; padding: 20px;} Learning objectives Create static and interactive maps using different packages Learn function structure to build more advanced maps Analyse the differences between used packages and identify their applicability for various purposes This chapter requires the following packages (some of them we used already): cran_packages_to_install &lt;- c( &quot;mapview&quot;, # map-making package for interactive maps &quot;tmap&quot;, # map-making package for static and interactive maps &quot;tidyverse&quot;, # metapackage containing dplyr, ggplot2 and other packages &quot;sf&quot;, # package for working with spatial data &quot;rnaturalearth&quot;, # data package &quot;rnaturalearthdata&quot;, # data package &quot;tmaptools&quot; # map building package ) install.packages(cran_packages_to_install) Next, we need to load the packages: library(tmap) library(mapview) library(ggplot2) library(sf) library(afrilearndata) library(rnaturalearth) library(rnaturalearthdata) library(dplyr) library(tmaptools) 5.2 Quick interactive maps with mapview Mapview package allows quickly and easily create interactive maps of spatial data. Therefore, it is useful when we want to quickly explore the data visually without excessive care about the quality of the presentation. However, if we need static maps or interactive maps which are more elaborate we might want to consider other options such as tmap package which will be presented later in this chapter. The typical spatial objects types supported by mapview package are: sf raster sp # data(africountries) # mapview(africountries) 5.3 Static maps with tmap In this section we explore the potential of tmap in creating static maps, which is a flexible, yet user-friendly package. Its syntax is similar to ggplot2 (plot-making package), where additional features of the map are simply build up on top of the basic structure. Before we plot the first maps we need to create a dataset called africa and activate static map viewing mode. africa &lt;- ne_countries(continent = &#39;africa&#39;, scale = &quot;medium&quot;, returnclass = &quot;sf&quot;) tmap_mode(&quot;plot&quot;) #activates static map viewing mode Next, we create an empty contour map of the continent, where tm_shape() function serves as a basic component containing the shape object i.e. our spatial dataset. On top of this basic building block we can then add more layers such as tm_borders() which defines the borders of the polygons. tm_shape(africa)+ tm_borders() Further, can also create an empty shape map using tm_fill() which defines the fill of the polygons. tm_shape(africa)+ tm_fill() Intuitively to create a map with both layers, we need to include tm_fill() and tm_borders() simultaneously. Alternatively, tm_polygons() function allows us to achieve exactly the same result more efficiently. tm_shape(africa)+ tm_borders()+ tm_fill() tm_shape(africa)+ tm_polygons() We can further develop our map by adjusting different features of the map such as colour and transparency of the map, width and types of the border lines etc. The extra parameters for changing the plot elements can be found here. tm_shape(africa)+ tm_polygons(col = &quot;green&quot;, lty = &quot;dotted&quot;, alpha = 0.3) As we already know a basic structure required to build a static map, we can proceed to a more advanced (and useful) example where we fill the polygons using data on last census, add relevant title to the legend. In this case, we also use legend.formatoption to format the legend numbers to be treated as years. tm_shape(africa)+ tm_fill(col=&quot;lastcensus&quot;, title=&quot;Year of last census&quot;, legend.format = list(format=&quot;s&quot;))+ tm_borders() We build on the previous map by adding labels for country names with tm_text function. tm_shape(africa)+ tm_fill(col=&quot;lastcensus&quot;, title=&quot;Year of last census&quot;, legend.format = list(format=&quot;s&quot;))+ tm_borders()+ tm_text(&quot;admin&quot;, size = 0.52, fontface=&quot;bold&quot;, auto.placement = TRUE) Another useful function in tmap is adjusting the intervals of the legend, in case the default scale does not provide enough variety. For example, when we try to see the populations of African countries on the map using default intervals stemming from the data we see: tm_shape(africa)+ tm_fill(col=&quot;pop_est&quot;, title=&quot;Population&quot;)+ tm_borders() Instead, we might want to use breaks argument to set them up manually to provide more differentiation visually. tm_shape(africa)+ tm_fill(col=&quot;pop_est&quot;, title=&quot;Population&quot;, breaks = c(1000000, 4000000, 8000000, 12000000, 16000000, 20000000, 24000000, 28000000,32000000))+ tm_borders() 5.3.1 Colour pallet An important aspect of the maps, as in every visual representation, are the colours. In tmap we can change the default colours using palette argument. tm_shape(africa)+ tm_fill(col=&quot;lastcensus&quot;, title=&quot;Year of last census&quot;, palette = &quot;Set1&quot;, legend.format = list(format=&quot;s&quot;))+ tm_borders() In the example above we used palette called Set1. To view possible options, run tmaptools::palette_explorer() which will open a new window with a wide range of palettes. Sliders on the left hand side allow selecting a number of colours. 5.3.2 Layers for the static maps tmap not only allows us to add extra layers to a single map by building on a basic structure, but it also enables us to join maps from different datasets. We first create an object called countries which is a single map with African countries: data(africountries) countries = tm_shape(africountries)+ tm_polygons(col=&quot;lightblue&quot;) countries Then we use it as an argument to merge it with a map containing the location of capitals. data(africapitals) countries+ tm_shape(africapitals)+ #uses dataset with capitals tm_dots(size=0.15) #adds dots on the map 5.3.3 Exercises The solution to the exercises are provided at the end of the chapter. div.purple { background-color:#e9d0f7; border-radius: 5px; padding: 20px;} Exercise 1: Change the settings to obtain a yellow, non-transparent map with solid line borders of width 3, as showed below. div.purple { background-color:#e9d0f7; border-radius: 5px; padding: 20px;} Exercise 2: Create a blue map with transparency of 0.3, dotted, non-transparent, red borders, as demonstrated below. div.purple { background-color:#e9d0f7; border-radius: 5px; padding: 20px;} Exercise 3: Create a map with polygons filled with gross domestic product, black borders, legend titled GDP and customised breaks at 0, 20000, 30000, 40000, 50000, 100000, 200000, 300000, 500000, such as seen below. 5.4 Interactive maps with tmap tmap offers versatility not only for creating static maps as we have seen above but it also allows us to make customised interactive maps conveniently by simply changing the mode of operation from static plot to dynamic view using tmap_mode() # tmap_mode(&quot;view&quot;) #switches to interactive mode # tm_shape(africa)+ #creates a map from previous chapter in an interactive mode # tm_borders() 5.5 Further resources 5.6 Exercise solutions Exercise 1 tm_shape(africa)+ tm_polygons(col = &quot;yellow&quot;, lwd = 3, lty = &quot;solid&quot;, alpha = 1) Exercise 2 tm_shape(africa)+ tm_fill(col=&quot;blue&quot;,alpha = 0.3)+ tm_borders(col = &quot;red&quot;, lty = &quot;dotted&quot;, alpha = 1) Exercise 3 tm_shape(africa)+ tm_fill(col=&quot;gdp_md_est&quot;, title=&quot;GDP&quot;, breaks = c(0, 20000, 30000, 40000, 50000, 100000,200000, 300000, 500000))+ tm_borders() "],["shiny.html", "Chapter 6 Shiny interactive map applications", " Chapter 6 Shiny interactive map applications Use of shiny package "],["data-sources.html", "Chapter 7 Sources of data", " Chapter 7 Sources of data See also https://rspatialdata.github.io/ R packages, Web APIs, OpenStreetMap intro, HDX 7.0.1 HDX "],["joining.html", "Chapter 8 Join non-spatial data onto spatial", " Chapter 8 Join non-spatial data onto spatial This chapter demonstrated how to join non-spatial data from different sources into spatial "],["raster.html", "Chapter 9 Raster manipulation", " Chapter 9 Raster manipulation e.g. summarising data by areas "],["openstreetmap.html", "Chapter 10 OpenStreetMap data", " Chapter 10 OpenStreetMap data what they are and how to use them? "],["data-editing.html", "Chapter 11 Creating and editing spatial data 11.1 Create a vector file from scratch", " Chapter 11 Creating and editing spatial data How to create and edit spatial data with examples 11.1 Create a vector file from scratch "],["visualising2.html", "Chapter 12 Visualising spatial data part 2", " Chapter 12 Visualising spatial data part 2 More advanced techniques of visualising of spatial data "],["case-study1.html", "Chapter 13 Case study 1 13.1 Health facility locations (probably)", " Chapter 13 Case study 1 13.1 Health facility locations (probably) "],["case-study2.html", "Chapter 14 Case study 2", " Chapter 14 Case study 2 To be decided "],["references.html", "References", " References Hijmans, R., J.(2020) Spatial Data Science. https://rspatial.org/intr/ "],["template.html", "Chapter 15 Template chapter 15.1 Linking section 1 15.2 Overall goal of the chapter 15.3 Episode 1 (topic 1) 15.4 Episode 2 (topic 2) 15.5 Episode 3 (topic 3) 15.6 Further resources 15.7 Wrap up 15.8 Exercise solutions 15.9 Feedback 15.10 Putting into practice", " Chapter 15 Template chapter 15.1 Linking section 1 This initial section of each lesson (chapter) should build a link with the previous section of the book by providing a recap of what has been previously done. It will help with locating each chapter within the context of the entire book. 15.2 Overall goal of the chapter In this section we will describe what the overall aim of this chapter and target audience including: What they are already expected to know (their previous knowledge) What are the goals of the audience div.green { background-color:#e3ffd9; border-radius: 5px; padding: 20px;} Learning objectives What you will learn What you will be able to do at the end of this chapter What you will not learn &amp; what to read instead Where to go from here List of episodes List of ‘episodes’ in this chapter that will help achieve set goal with their short description and an explanation of links between them. Episode 1 Episode 2 Episode 3 15.3 Episode 1 (topic 1) Each episode developed within the chapter should contain a narrative to give a bit of a context and again demonstrate the target audience (if needed). Beyond it should provide episode-specific learning objectives and examples, which are to be intertwined with so-called self-check exercises which will allow the reader to assess his comprehension of the topic so far. div.purple { background-color:#e9d0f7; border-radius: 5px; padding: 20px;} Exercise 1: The exercise description to be in the coloured box &amp; the small, control exercises should be placed at the end of the subsection. 15.4 Episode 2 (topic 2) div.yellow { background-color:#fff5e6; border-radius: 5px; padding: 20px;} Shortcut: Shortcuts to be in a yellow box. 15.5 Episode 3 (topic 3) div.blue { background-color:#e6f0ff; border-radius: 5px; padding: 20px;} Hints: Hints to be in a blue box. 15.6 Further resources In this section we provide links to additional websites and sources that are useful in a given topic or package in the following way: R website Documentation pages 15.7 Wrap up This closing section should show the reader what has been done in this chapter and how it links with the topics provided in the next chapter by a brief introduction to next topic. 15.8 Exercise solutions Exercise 1 #code to exercise 1 only, results hidden Exercise 2 #code to exercise 2 only, results hidden 15.9 Feedback Feedback section aims at learning what was useful to the reader (learner) and what can be improved. It gives the reader an opportunity to reflect on what he/she learned and evaluate the book in this this context. 15.10 Putting into practice This final section is aimed at consolidating the knowledge and skills learned throughout the whole chapter, where the reader can put them into practice in a more complex working example with a new context. "]]
