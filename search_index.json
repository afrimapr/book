[["index.html", "The afrimapr book Welcome", " The afrimapr book The afrimapr team 2021-02-15 Welcome This is the in-progress book introducing map making in R using African data. It is part of the afrimapr project running in 2020-21. We welcome contributions, and will make avenues for contribution clearer soon. In the meantime, do get in touch. "],["preface.html", "Preface", " Preface [defined in index.Rmd] [andy:links to chapters sometimes don’t work for unknown reasons] [https://bookdown.org/yihui/bookdown/cross-references.html] In-progress chapters Intro : aims of this book 1 Step through a simple example of process of mapmaking 2 R recap - help ensure readers know foundations 3 Spatial data types focusing on examples 4 Visualising spatial data part 1 : sf, mapview, tmap 5 Shiny interactive map applications 6 Sources of data, what is open data 7 Join non-spatial data onto spatial 8 Raster manipulation, e.g. summarising data by areas 9 OpenStreetMap data, what they are and how to use 10 Creating and editing spatial data 11 Visualising spatial data part 2, more advanced techniques 12 Case study 1 : health facility locations 13 Case study 2 14 The version of the book you are currently reading was last updated at: Sys.time() ## [1] &quot;2021-02-15 04:51:14 UTC&quot; Continuous integration (built on GitHub) "],["intro.html", "Chapter 1 Introduction 1.1 Spatial data outline", " Chapter 1 Introduction This first chapter is an entry level introduction to spatial data in R using examples from Africa. It is aimed at those with a little knowledge of R. 1.1 Spatial data outline We will start by looking at these spatial data for Africa, shown in the map below. Capital city locations (points) A highway network (lines) Country boundaries (polygons) Population density (gridded or raster data) Cities, highways and boundaries are examples of point, line and polygon data termed vector data. The gridded population density data are termed raster data. In R there is often more than one package that does the same thing. Which one is ‘best’ for you may depend on preference and can change over time. This is true for R spatial operations. In R the sf package deals with vector data (points, lines and polygons), and the raster package deals with raster data. There are other packages too but we don’t need those for now. "],["steps1.html", "Chapter 2 Step through a simple example of process of mapmaking", " Chapter 2 Step through a simple example of process of mapmaking Step through a simple example of process of map-making. Demonstrate a simple step by step process of making a map with relatively little explanation. To show the readers what we are aiming for and that this is achievable. Then in later chapters we will work to fill in the gaps in understanding https://speakerdeck.com/minecr/let-them-eat-cake-first "],["rrecap.html", "Chapter 3 R recap 3.1 Setting working directory 3.2 Creating, naming and saving a new R script 3.3 Executing the code 3.4 Install and load packages 3.5 Load data 3.6 Basic data types 3.7 Basic objects and data structures", " Chapter 3 R recap Previous section demonstrated what can be achieved with the learning materials provided in this book and gave an example of capabilities of packages that are used. In contrast, this section summarises basic steps that are required (or useful) to do before starting the project and provides a brief recap of R fundamentals such as data types and structures, objects and commands. It aims at building a starting point for those who are new to R software and provide basic background knowledge that the reader can build on while progressing through the further chapters of this book. This chapter will be particularly useful to beginners, who have minimal knowledge of R. Therefore, more advanced readers an move on to the next chapter where spatial data types are looked into. 3.1 Setting working directory At the beginning of each project it is crucial to determine the working directory for your project. A working directory is a folder where all your files associated with the project will be stored. For example, original datasets, saved datasets as well as plots, graphs or maps created and exported from R. Hence, working directory not only allows you to gather and access the files produced along the work but also load the existing datasets into the RStudio. You can set up the working directory with the openProject function as follows (recommended): rstudioapi::openProject(&quot;path to your directory&quot;) Alternatively, you can use the following command: setwd(&quot;path to your directory&quot;) While the former option will set up and open the working directory for your project, the latter simply determines the default folder for each specific R script. 3.2 Creating, naming and saving a new R script The R script is a plain text file that allows you to save the R code containing both, commands and comments. Saving the R script allows you to reuse your R code and creates a reproducible record of your work. Therefore, it is a good practice to create, name and save it at the very beginning of your project. You can crate a new R script by clicking the New File icon in the top right corner of the RStudio toolbar, which will open a list with different file options. Choose the R Script from the menu and the blank script will open in the main RStudio window. div.yellow { background-color:#fff5e6; border-radius: 5px; padding: 20px;} Shortcut: New R script can also be opened by Shift+Ctrl+N. You can now save your R script by clicking on the Save icon at the top of the Script Editor, this will prompt a Save File window where you can change the name of your script. Note that the file extension for R scripts is .R. At this point you can also choose a folder where to save your new file. By default, RStudio will try to save your new script in the current working directory. Once the name and file location are chosen, simply click the Save button. div.yellow { background-color:#fff5e6; border-radius: 5px; padding: 20px;} Shortcut: As you work along your R script document, you can quickly save changes by pressing Ctrl+S. 3.3 Executing the code Now, as you set up the working directory for your project and created your first R script file, we will look into ways of executing (also known as running) the code. You can execute selected chunk of code by clicking Run button at the top right corner of the Script Editor. div.yellow { background-color:#fff5e6; border-radius: 5px; padding: 20px;} Shortcut: You can also execute the selected code with Ctrl+Enter. If you do not select any code and press Run, RStudio will run the line of code where the cursor is located. The code which has been exectued will appear in the Console, usually located at the bottom part of the window. In RStudio it is also possible to add comments next to your commands simply using a hashtag (#) beforehand. This will stop R from executing this specific part: 3+6 # Using R as a calculator ## [1] 9 # 3+6 3.4 Install and load packages 3.5 Load data There are different approaches that can be used to import your datasets, depending on where the data is located and in what file type it is stored. The easiest case is when the dataset is already part of the R package, as it will be automatically read in when the package is installed and loaded into R. For example, install packages containing dataset: remotes::install_github(&quot;afrimapr/afrilearndata&quot;) Load them: library(afrilearndata) To view what datasets are available in a given package: data(package=&quot;afrilearndata&quot;) We can view and explore the africapitals dataset using: head(africapitals) ## capitalname countryname pop iso3c geometry ## 280 Abuja Nigeria 178462 NGA 7.17, 9.18 ## 308 Accra Ghana 2029143 GHA -0.20, 5.56 ## 382 Addis Abeba Ethiopia 2823167 ETH 38.74, 9.03 ## 996 Algiers Algeria 2029936 DZA 3.04, 36.77 ## 1584 Antananarivo Madagascar 1463754 MDG 47.51, -18.89 ## 2193 Asmara Eritrea 578860 ERI 38.94, 15.33 We can also create a dataframe from africapitals in the global environment: dataset &lt;- africapitals 3.6 Basic data types In this section we explore a basic set of possible object types that you can encounter in a dataframe. The division presented below is based on the types of values that data (object) stores. The most popular data types are: Numeric Character Logical (so-called Boolean) Factor In R the type of object is referred to as class of an object and this function can be used to learn what data types the object contains. x &lt;- 11 #we create a vector that stores value 11 class(x) ## [1] &quot;numeric&quot; It is useful because each class has different properties and can be used in a different way. For example, intuitively we can perform the mathematical operations on numeric objects such that: x &lt;- 11 y &lt;- 52 x*y # multiplication ## [1] 572 div.blue { background-color:#e6f0ff; border-radius: 5px; padding: 20px;} Hint: To assign a value to an object two operators can be used interchangeably: &lt;- or =. 3.6.1 Numeric and integer Numeric data stores real numbers. This means that the object x from above is in fact 11.000000, where the zeros are not printed, by default. It is also possible to store value as whole number in a class object called integer. An integer can be created from a numeric object in the following way: x &lt;- 13.5 z &lt;- as.integer(x) class(z) ## [1] &quot;integer&quot; Please note, even though the numeric value is a decimal number the integer by default rounds downwards, hence both 13.1 and 13.9 will result in integer equal 13. 3.6.2 Characters Character objects store text, usually referred to as a string. String can be a letter, word or even a sentence. x &lt;- &quot;adult&quot; y &lt;- &quot;A&quot; y &lt;- &quot;I have a bicycle.&quot; Interestingly, a character can also contain a number, however it will be stored as a text and will not have the same properties as a numeric or integer object. As a results, it will not be possible to perform calculation on character objects, even if they contain numbers. This is when class function becomes helpful. x &lt;- &quot;5&quot; y &lt;- 7 class(x) ## [1] &quot;character&quot; class(y) ## [1] &quot;numeric&quot; It is also possible to convert character variables into numeric: x &lt;- &quot;5&quot; z &lt;- as.numeric(x) class(z) ## [1] &quot;numeric&quot; 3.6.3 Logical Logical objects can take values TRUE or FALSE, where TRUE is an equivalent of 1 whereas FALSE is an equivalent of 0. In these sense, they can be thought of as numerical values. x &lt;- TRUE y &lt;- 3+TRUE print(y) ## [1] 4 Typically, logical objects are results of a condition. For example, if we want to test if object a is larger than 100. a &lt;- 76 #create object a a &gt; 100 # condition 1 ## [1] FALSE a &lt; 80 # condition 2 ## [1] TRUE 3.6.4 Factors Factors are categorical variables with associated levels. They can store both, numbers: a &lt;- rep(1:3, times=3) # create a vector of numbers from 1 to 3, repeated 3 times a &lt;- as.factor(a) a ## [1] 1 2 3 1 2 3 1 2 3 ## Levels: 1 2 3 and strings: b &lt;- c(&quot;A&quot;, &quot;B&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;C&quot;, &quot;C&quot;) b &lt;- as.factor(b) b ## [1] A B B C D C C ## Levels: A B C D The numbers and strings, in the example above, serve as labels of different levels. 3.7 Basic objects and data structures In this section we explain the basic data structures that we often work with in R. These include a vector, list, matrix and a dataframe. 3.7.1 Vector Vector is a one dimensional structure which contains elements of the same type. Usually a combine function is used to create a vector such that: a &lt;- c(1:10) It is also possible to create a vector with text-based objects, for example with capitals from our afrilearndata: capitals &lt;- africapitals$capitalname We can print content of our vector to see what it contains: print(capitals) ## [1] &quot;Abuja&quot; &quot;Accra&quot; &quot;Addis Abeba&quot; &quot;Algiers&quot; &quot;Antananarivo&quot; ## [6] &quot;Asmara&quot; &quot;Bamako&quot; &quot;Bangui&quot; &quot;Banjul&quot; &quot;Bissau&quot; ## [11] &quot;Brazzaville&quot; &quot;Bujumbura&quot; &quot;Cairo&quot; &quot;Conakry&quot; &quot;Dakar&quot; ## [16] &quot;Dodoma&quot; &quot;Freetown&quot; &quot;Gaborone&quot; &quot;Harare&quot; &quot;Jibuti&quot; ## [21] &quot;Kampala&quot; &quot;Khartoum&quot; &quot;Kigali&quot; &quot;Kinshasa&quot; &quot;Libreville&quot; ## [26] &quot;Lilongwe&quot; &quot;Lome&quot; &quot;Luanda&quot; &quot;Lusaka&quot; &quot;Malabo&quot; ## [31] &quot;Maputo&quot; &quot;Maseru&quot; &quot;Mbabane&quot; &quot;Mogadishu&quot; &quot;Monrovia&quot; ## [36] &quot;N&#39;Djamena&quot; &quot;Nairobi&quot; &quot;Niamey&quot; &quot;Nouakchott&quot; &quot;Ouagadougou&quot; ## [41] &quot;Porto Novo&quot; &quot;Pretoria&quot; &quot;Rabat&quot; &quot;Tripoli&quot; &quot;Tunis&quot; ## [46] &quot;Windhoek&quot; &quot;Yamoussoukro&quot; &quot;Yaounde&quot; &quot;al-&#39;Ayun&quot; &quot;Juba&quot; Another important feature is to see what types of objects the vector stores. We can see that our text-based objects are characters using typeof function: typeof(capitals) ## [1] &quot;character&quot; 3.7.2 Matrix Matrix can be though of as an upgraded version of a vector, where vector is an one-dimensional array and two-dimensional array. We can create a matrix that has three columns and five rows with the following: matrix(1:15, ncol=3, nrow=5, byrow = TRUE) ## [,1] [,2] [,3] ## [1,] 1 2 3 ## [2,] 4 5 6 ## [3,] 7 8 9 ## [4,] 10 11 12 ## [5,] 13 14 15 By default, the elements in the matrix will be arranged by column, so byrow=TRUE segregates the elements in the matrix row-wise. We can also exploit the fact that matrix is an upgraded vector by binding them column- or row-wise, as long as they have the same length: vector1 &lt;- c(&quot;water&quot;, &quot;milk&quot;, &quot;juice&quot;) vector2 &lt;- (1:3) cbind(vector1, vector2) #for row-wise binding we would use rbind() ## vector1 vector2 ## [1,] &quot;water&quot; &quot;1&quot; ## [2,] &quot;milk&quot; &quot;2&quot; ## [3,] &quot;juice&quot; &quot;3&quot; 3.7.3 Data frame Data frame is a two dimensional array, similar to a matrix. However, it can contain different data types, unlike matrix. Beyond, columns as well as rows within the data frame are named. In a data frame a column is a variable and row is an observation. You can create a simple data frame with two columns and three rows, using vectors above, with data.frame function: data.frame(vector1, vector2) ## vector1 vector2 ## 1 water 1 ## 2 milk 2 ## 3 juice 3 If you compare the output of the example above where we used the cbind function to create a matrix, to the result of the data.frame function, we can clearly see the difference between a matrix and a data frame. Where matrix is homogeneous and data frame is heterogeneous in terms of data type. All the values in the matrix are characters while the first column in data frame contains factors and the second one integers. To address a specific column in a data frame we can use $ such that: df_1 = data.frame(vector1, vector2) #create data frame called df_1 df_1$vector1 #view column called vector1 ## [1] &quot;water&quot; &quot;milk&quot; &quot;juice&quot; At the moment columns in the df_1 adapted names of the vectors: colnames(df_1) ## [1] &quot;vector1&quot; &quot;vector2&quot; We can change the column headers by their names or their index such that: names(df_1)[names(df_1) == &quot;vector1&quot;] &lt;- &quot;drinks&quot; names(df_1)[2] &lt;- &quot;amount&quot; colnames(df_1) ## [1] &quot;drinks&quot; &quot;amount&quot; "],["data-types.html", "Chapter 4 Spatial data types focusing on real examples: cities, roads, admin boundaries, surfaces 4.1 Points e.g. cities 4.2 Lines e.g. roads 4.3 Polygons e.g. admin boundaries 4.4 Raster e.g. modelled population estimates", " Chapter 4 Spatial data types focusing on real examples: cities, roads, admin boundaries, surfaces Capital city locations (points) A highway network (lines) Country boundaries (polygons) Population density (gridded or raster data) 4.1 Points e.g. cities 4.2 Lines e.g. roads 4.3 Polygons e.g. admin boundaries 4.4 Raster e.g. modelled population estimates "],["visualising1.html", "Chapter 5 Visualising spatial data part 1: tmap and mapview 5.1 Quick interactive maps with mapview 5.2 Static maps with tmap 5.3 Interactive maps with tmap", " Chapter 5 Visualising spatial data part 1: tmap and mapview In this section we will visualise spatial data, in particular we will use tmap and mapview to crate both static and interactive maps. This chapter requires the following packages (some of them we used already): cran_packages_to_install &lt;- c( &quot;mapview&quot;, # map-making package for interactive maps &quot;tmap&quot;, # map-making package for static and interactive maps &quot;tidyverse&quot;, # metapackage containing dplyr, ggplot2 and other packages &quot;sf&quot;, # package for working with spatial data &quot;rnaturalearth&quot;, # data package &quot;rnaturalearthdata&quot; # data package ) install.packages(cran_packages_to_install) #remotes::install_github(&quot;afrimapr/afrilearndata&quot;) Next, we need to load the packages: library(tmap) library(mapview) library(ggplot2) library(sf) library(afrilearndata) library(rnaturalearth) library(rnaturalearthdata) library(dplyr) 5.1 Quick interactive maps with mapview Mapview package allows quickly and easily create interactive maps of spatial data. Therefore, it is useful when we want to quickly explore the data visually without excessive care about the quality of the presentation. However, if we need static maps or interactive maps which are more elaborate we might want to consider other options such as tmap package which will be presented later in this chapter. The typical spatial objects types supported by mapview package are: sf raster sp #mapview(africountries) 5.2 Static maps with tmap In this section we will explore the possibilities of tmap in creating static maps, which is a flexible, yet user-friendly package. Its syntax is similar to ggplot2 (plot-making package), where additional features of the map are simply build up on top of the basic structure. It will be demonstrated below, where we will start off with a simple contour map and then we will add more Create a dataset africa &lt;- ne_countries(continent = &#39;africa&#39;, scale = &quot;medium&quot;, returnclass = &quot;sf&quot;) Create an empty contour map of the continent tm_shape(africa)+ tm_borders() 5.2.1 Layers for the static maps Fill map using data on last census data and add labels for country names tm_shape(africa)+ tm_fill(col=&quot;lastcensus&quot;, title=&quot;Year of last census&quot;, legend.format = list(format=&quot;s&quot;))+ tm_borders()+ tm_text(&quot;admin&quot;, size = 0.52, fontface=&quot;bold&quot;, auto.placement = TRUE) 5.2.2 Colour pallet 5.3 Interactive maps with tmap tmap offers versatility not only for creating static maps as we see above but it also allows us to make customised interactive maps conveniently by simply changing the mode of operation from static to dynamic using tmap_mode() "],["shiny.html", "Chapter 6 Shiny interactive map applications", " Chapter 6 Shiny interactive map applications Use of shiny package "],["data-sources.html", "Chapter 7 Sources of data", " Chapter 7 Sources of data See also https://rspatialdata.github.io/ R packages, Web APIs, OpenStreetMap intro, HDX 7.0.1 HDX "],["joining.html", "Chapter 8 Join non-spatial data onto spatial", " Chapter 8 Join non-spatial data onto spatial This chapter demonstrated how to join non-spatial data from different sources into spatial "],["raster.html", "Chapter 9 Raster manipulation", " Chapter 9 Raster manipulation e.g. summarising data by areas "],["openstreetmap.html", "Chapter 10 OpenStreetMap data", " Chapter 10 OpenStreetMap data what they are and how to use them? "],["data-editing.html", "Chapter 11 Creating and editing spatial data 11.1 Create a vector file from scratch", " Chapter 11 Creating and editing spatial data How to create and edit spatial data with examples 11.1 Create a vector file from scratch "],["visualising2.html", "Chapter 12 Visualising spatial data part 2", " Chapter 12 Visualising spatial data part 2 More advanced techniques of visualising of spatial data "],["case-study1.html", "Chapter 13 Case study 1 13.1 Health facility locations (probably)", " Chapter 13 Case study 1 13.1 Health facility locations (probably) "],["case-study2.html", "Chapter 14 Case study 2", " Chapter 14 Case study 2 To be decided "],["references.html", "References", " References Hijmans, R., J.(2020) Spatial Data Science. https://rspatial.org/intr/ "],["template.html", "Chapter 15 Template chapter 15.1 Linking section 1 15.2 Overall goal of the chapter 15.3 Episode 1 (topic 1) 15.4 Episode 2 (topic 2) 15.5 Episode 3 (topic 3) 15.6 Linking section 2", " Chapter 15 Template chapter 15.1 Linking section 1 This initial section of each lesson (chapter) should build a link with the previous section of the book by providing a recap of what has been previously done. It will help with placing each chapter within the context of the entire book. 15.2 Overall goal of the chapter In this section we will describe what is the overall aim of this chapter, including: Learning objectives: What will you learn? What you will be able to do at the end of this chapter What you will not learn &amp; what to read instead Where to go from here List of ‘episodes’ in this chapter that will help achieve set goal with their short description and an explanation of links between them Targeted audience What they are expected to already know (their previous knowledge) What are the goals of the audience 15.3 Episode 1 (topic 1) Each episode developed within the chapter should contain a narrative to give a bit of a context and again demonstrate the target audience. Beyond it should provide episode-specific learning objectives and examples, which are to be intertwined with so-called self-check exercises which will allow the reader to assess his comprehension of the topic so far. 15.4 Episode 2 (topic 2) 15.5 Episode 3 (topic 3) 15.6 Linking section 2 This closing section should show the reader what has been done in this chapter and how it links with the topics provided in the next chapter by a brief introduction to next topic. ## Feedback request on what was useful to the reader (learner) and what can be improved "]]
